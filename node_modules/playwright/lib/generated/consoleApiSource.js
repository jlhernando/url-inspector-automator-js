"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/debug/injected/consoleApi.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/debug/injected/consoleApi.ts\":\n/*!******************************************!*\\\n  !*** ./src/debug/injected/consoleApi.ts ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConsoleAPI = void 0;\nconst selectorGenerator_1 = __webpack_require__(/*! ./selectorGenerator */ \"./src/debug/injected/selectorGenerator.ts\");\nclass ConsoleAPI {\n    constructor(injectedScript) {\n        this._injectedScript = injectedScript;\n        if (window.playwright)\n            return;\n        window.playwright = {\n            $: (selector) => this._querySelector(selector),\n            $$: (selector) => this._querySelectorAll(selector),\n            inspect: (selector) => this._inspect(selector),\n            selector: (element) => this._selector(element),\n        };\n    }\n    _querySelector(selector) {\n        if (typeof selector !== 'string')\n            throw new Error(`Usage: playwright.query('Playwright >> selector').`);\n        const parsed = this._injectedScript.parseSelector(selector);\n        return this._injectedScript.querySelector(parsed, document);\n    }\n    _querySelectorAll(selector) {\n        if (typeof selector !== 'string')\n            throw new Error(`Usage: playwright.$$('Playwright >> selector').`);\n        const parsed = this._injectedScript.parseSelector(selector);\n        return this._injectedScript.querySelectorAll(parsed, document);\n    }\n    _inspect(selector) {\n        if (typeof window.inspect !== 'function')\n            return;\n        if (typeof selector !== 'string')\n            throw new Error(`Usage: playwright.inspect('Playwright >> selector').`);\n        window.inspect(this._querySelector(selector));\n    }\n    _selector(element) {\n        if (!(element instanceof Element))\n            throw new Error(`Usage: playwright.selector(element).`);\n        return selectorGenerator_1.generateSelector(this._injectedScript, element).selector;\n    }\n}\nexports.ConsoleAPI = ConsoleAPI;\nexports.default = ConsoleAPI;\n\n\n/***/ }),\n\n/***/ \"./src/debug/injected/selectorGenerator.ts\":\n/*!*************************************************!*\\\n  !*** ./src/debug/injected/selectorGenerator.ts ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSelector = void 0;\nfunction generateSelector(injectedScript, targetElement) {\n    const path = [];\n    let numberOfMatchingElements = Number.MAX_SAFE_INTEGER;\n    for (let element = targetElement; element && element !== document.documentElement; element = parentElementOrShadowHost(element)) {\n        const selector = buildSelectorCandidate(element);\n        if (!selector)\n            continue;\n        const fullSelector = joinSelector([selector, ...path]);\n        const parsedSelector = injectedScript.parseSelector(fullSelector);\n        const selectorTargets = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n        if (!selectorTargets.length)\n            break;\n        if (selectorTargets[0] === targetElement)\n            return { selector: fullSelector, elements: selectorTargets };\n        if (selectorTargets.length && numberOfMatchingElements > selectorTargets.length) {\n            numberOfMatchingElements = selectorTargets.length;\n            path.unshift(selector);\n        }\n    }\n    if (document.documentElement === targetElement) {\n        return {\n            selector: '/html',\n            elements: [document.documentElement]\n        };\n    }\n    const selector = createXPath(document.documentElement, targetElement) ||\n        cssSelectorForElement(injectedScript, targetElement);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n        selector,\n        elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n}\nexports.generateSelector = generateSelector;\nfunction buildSelectorCandidate(element) {\n    const nodeName = element.nodeName.toLowerCase();\n    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {\n        if (element.hasAttribute(attribute))\n            return { engine: 'css', selector: `${nodeName}[${attribute}=${quoteString(element.getAttribute(attribute))}]` };\n    }\n    for (const attribute of ['aria-label', 'role']) {\n        if (element.hasAttribute(attribute))\n            return { engine: 'css', selector: `${element.nodeName.toLocaleLowerCase()}[${attribute}=${quoteString(element.getAttribute(attribute))}]` };\n    }\n    if (['INPUT', 'TEXTAREA'].includes(element.nodeName)) {\n        const nodeNameLowercase = element.nodeName.toLowerCase();\n        if (element.getAttribute('name'))\n            return { engine: 'css', selector: `${nodeNameLowercase}[name=${quoteString(element.getAttribute('name'))}]` };\n        if (element.getAttribute('placeholder'))\n            return { engine: 'css', selector: `${nodeNameLowercase}[placeholder=${quoteString(element.getAttribute('placeholder'))}]` };\n        if (element.getAttribute('type'))\n            return { engine: 'css', selector: `${nodeNameLowercase}[type=${quoteString(element.getAttribute('type'))}]` };\n    }\n    else if (element.nodeName === 'IMG') {\n        if (element.getAttribute('alt'))\n            return { engine: 'css', selector: `img[alt=${quoteString(element.getAttribute('alt'))}]` };\n    }\n    const textSelector = textSelectorForElement(element);\n    if (textSelector)\n        return { engine: 'text', selector: textSelector };\n    // De-prioritize id, but still use it as a last resort.\n    const idAttr = element.getAttribute('id');\n    if (idAttr && !isGuidLike(idAttr))\n        return { engine: 'css', selector: `${nodeName}[id=${quoteString(idAttr)}]` };\n    return null;\n}\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return null;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n    return null;\n}\nfunction cssSelectorForElement(injectedScript, targetElement) {\n    const root = targetElement.ownerDocument;\n    const tokens = [];\n    function uniqueCSSSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        const selector = path.join(' ');\n        const parsedSelector = injectedScript.parseSelector(selector);\n        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);\n        return node === targetElement ? selector : undefined;\n    }\n    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n        const nodeName = element.nodeName.toLowerCase();\n        // Element ID is the strongest signal, use it.\n        let bestTokenForLevel = '';\n        if (element.id) {\n            const token = /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(element.id) ? '#' + element.id : `[id=\"${element.id}\"]`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return selector;\n            bestTokenForLevel = token;\n        }\n        const parent = element.parentNode;\n        // Combine class names until unique.\n        const classes = Array.from(element.classList);\n        for (let i = 0; i < classes.length; ++i) {\n            const token = '.' + classes.slice(0, i + 1).join('.');\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return selector;\n            // Even if not unique, does this subset of classes uniquely identify node as a child?\n            if (!bestTokenForLevel && parent) {\n                const sameClassSiblings = parent.querySelectorAll(token);\n                if (sameClassSiblings.length === 1)\n                    bestTokenForLevel = token;\n            }\n        }\n        // Ordinal is the weakest signal.\n        if (parent) {\n            const siblings = Array.from(parent.children);\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return selector;\n            if (!bestTokenForLevel)\n                bestTokenForLevel = token;\n        }\n        else if (!bestTokenForLevel) {\n            bestTokenForLevel = nodeName;\n        }\n        tokens.unshift(bestTokenForLevel);\n    }\n    return uniqueCSSSelector();\n}\nfunction textSelectorForElement(node) {\n    const maxLength = 30;\n    let needsRegex = false;\n    let trimmedText = null;\n    for (const child of node.childNodes) {\n        if (child.nodeType !== Node.TEXT_NODE)\n            continue;\n        if (child.textContent && child.textContent.trim()) {\n            if (trimmedText)\n                return null;\n            trimmedText = child.textContent.trim().substr(0, maxLength);\n            needsRegex = child.textContent !== trimmedText;\n        }\n        else {\n            needsRegex = true;\n        }\n    }\n    if (!trimmedText)\n        return null;\n    return needsRegex ? `/.*${escapeForRegex(trimmedText)}.*/` : `\"${trimmedText}\"`;\n}\nfunction escapeForRegex(text) {\n    return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction quoteString(text) {\n    return `\"${text.replaceAll(/\"/g, '\\\\\"')}\"`;\n}\nfunction joinSelector(path) {\n    const tokens = [];\n    let lastEngine = '';\n    for (const { engine, selector } of path) {\n        if (tokens.length && (lastEngine !== 'css' || engine !== 'css'))\n            tokens.push('>>');\n        lastEngine = engine;\n        if (engine === 'css')\n            tokens.push(selector);\n        else\n            tokens.push(`${engine}=${selector}`);\n    }\n    return tokens.join(' ');\n}\nfunction isGuidLike(id) {\n    let lastCharacterType;\n    let transitionCount = 0;\n    for (let i = 0; i < id.length; ++i) {\n        const c = id[i];\n        let characterType;\n        if (c === '-' || c === '_')\n            continue;\n        if (c >= 'a' && c <= 'z')\n            characterType = 'lower';\n        else if (c >= 'A' && c <= 'Z')\n            characterType = 'upper';\n        else if (c >= '0' && c <= '9')\n            characterType = 'digit';\n        else\n            characterType = 'other';\n        if (characterType === 'lower' && lastCharacterType === 'upper') {\n            lastCharacterType = characterType;\n            continue;\n        }\n        if (lastCharacterType && lastCharacterType !== characterType)\n            ++transitionCount;\n        lastCharacterType = characterType;\n    }\n    return transitionCount >= id.length / 4;\n}\nfunction createXPath(root, targetElement) {\n    const maxTextLength = 80;\n    const minMeaningfulSelectorLegth = 100;\n    const maybeDocument = root instanceof Document ? root : root.ownerDocument;\n    if (!maybeDocument)\n        return;\n    const document = maybeDocument;\n    const xpathCache = new Map();\n    const tokens = [];\n    function evaluateXPath(expression) {\n        let nodes = xpathCache.get(expression);\n        if (!nodes) {\n            nodes = [];\n            try {\n                const result = document.evaluate(expression, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n                for (let node = result.iterateNext(); node; node = result.iterateNext()) {\n                    if (node.nodeType === Node.ELEMENT_NODE)\n                        nodes.push(node);\n                }\n            }\n            catch (e) {\n            }\n            xpathCache.set(expression, nodes);\n        }\n        return nodes;\n    }\n    function uniqueXPathSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        let selector = '//' + path.join('/');\n        while (selector.includes('///'))\n            selector = selector.replace('///', '//');\n        if (selector.endsWith('/'))\n            selector = selector.substring(0, selector.length - 1);\n        const nodes = evaluateXPath(selector);\n        if (nodes[0] === targetElement)\n            return selector;\n        // If we are looking at a small set of elements with long selector, fall back to ordinal.\n        if (nodes.length < 5 && selector.length > minMeaningfulSelectorLegth) {\n            const index = nodes.indexOf(targetElement);\n            if (index !== -1)\n                return `(${selector})[${index + 1}]`;\n        }\n        return undefined;\n    }\n    function escapeAndCap(text) {\n        text = text.substring(0, maxTextLength);\n        // XPath 1.0 does not support quote escaping.\n        // 1. If there are no single quotes - use them.\n        if (text.indexOf(`'`) === -1)\n            return `'${text}'`;\n        // 2. If there are no double quotes - use them to enclose text.\n        if (text.indexOf(`\"`) === -1)\n            return `\"${text}\"`;\n        // 3. Otherwise, use popular |concat| trick.\n        const Q = `'`;\n        return `concat(${text.split(Q).map(token => Q + token + Q).join(`, \"'\", `)})`;\n    }\n    const defaultAttributes = new Set(['title', 'aria-label', 'disabled', 'role']);\n    const importantAttributes = new Map([\n        ['form', ['action']],\n        ['img', ['alt']],\n        ['input', ['placeholder', 'type', 'name']],\n        ['textarea', ['placeholder', 'type', 'name']],\n    ]);\n    let usedTextConditions = false;\n    for (let element = targetElement; element && element !== root; element = element.parentElement) {\n        const nodeName = element.nodeName.toLowerCase();\n        const tag = nodeName === 'svg' ? '*' : nodeName;\n        const tagConditions = [];\n        if (nodeName === 'svg')\n            tagConditions.push('local-name()=\"svg\"');\n        const attrConditions = [];\n        const importantAttrs = [...defaultAttributes, ...(importantAttributes.get(tag) || [])];\n        for (const attr of importantAttrs) {\n            const value = element.getAttribute(attr);\n            if (value && value.length < maxTextLength)\n                attrConditions.push(`normalize-space(@${attr})=${escapeAndCap(value)}`);\n            else if (value)\n                attrConditions.push(`starts-with(normalize-space(@${attr}), ${escapeAndCap(value)})`);\n        }\n        const text = document.evaluate('normalize-space(.)', element).stringValue;\n        const textConditions = [];\n        if (tag !== 'select' && text.length && !usedTextConditions) {\n            if (text.length < maxTextLength)\n                textConditions.push(`normalize-space(.)=${escapeAndCap(text)}`);\n            else\n                textConditions.push(`starts-with(normalize-space(.), ${escapeAndCap(text)})`);\n            usedTextConditions = true;\n        }\n        // Always retain the last tag.\n        const conditions = [...tagConditions, ...textConditions, ...attrConditions];\n        const token = conditions.length ? `${tag}[${conditions.join(' and ')}]` : (tokens.length ? '' : tag);\n        const selector = uniqueXPathSelector(token);\n        if (selector)\n            return selector;\n        const parent = element.parentElement;\n        let ordinal = -1;\n        if (parent) {\n            const siblings = Array.from(parent.children);\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            if (sameTagSiblings.length > 1)\n                ordinal = sameTagSiblings.indexOf(element);\n        }\n        // Do not include text into this token, only tag / attributes.\n        // Topmost node will get all the text.\n        const conditionsString = conditions.length ? `[${conditions.join(' and ')}]` : '';\n        const ordinalString = ordinal >= 0 ? `[${ordinal + 1}]` : '';\n        tokens.unshift(`${tag}${ordinalString}${conditionsString}`);\n    }\n    return uniqueXPathSelector();\n}\n\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=consoleApiSource.js.map