"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.source = void 0;
exports.source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/cli/injected/recorder.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/cli/injected/html.ts\":\n/*!**********************************!*\\\n  !*** ./src/cli/injected/html.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepActiveElement = exports.html = exports.onDOMResize = exports.onDOMEvent = void 0;\nconst templateCache = new Map();\nconst BOOLEAN_ATTRS = new Set([\n    'async', 'autofocus', 'autoplay', 'checked', 'contenteditable', 'controls',\n    'default', 'defer', 'disabled', 'expanded', 'formNoValidate', 'frameborder', 'hidden',\n    'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate',\n    'open', 'readonly', 'required', 'reversed', 'scoped', 'selected', 'typemustmatch',\n]);\nfunction onDOMEvent(target, name, listener, capturing = false) {\n    target.addEventListener(name, listener, capturing);\n    return () => {\n        target.removeEventListener(name, listener, capturing);\n    };\n}\nexports.onDOMEvent = onDOMEvent;\nfunction onDOMResize(target, callback) {\n    const resizeObserver = new window.ResizeObserver(callback);\n    resizeObserver.observe(target);\n    return () => resizeObserver.disconnect();\n}\nexports.onDOMResize = onDOMResize;\nfunction html(strings, ...values) {\n    let cache = templateCache.get(strings);\n    if (!cache) {\n        cache = prepareTemplate(strings);\n        templateCache.set(strings, cache);\n    }\n    const node = renderTemplate(cache.template, cache.subs, values);\n    if (node.querySelector) {\n        node.$ = node.querySelector.bind(node);\n        node.$$ = node.querySelectorAll.bind(node);\n    }\n    return node;\n}\nexports.html = html;\nconst SPACE_REGEX = /^\\s*\\n\\s*$/;\nconst MARKER_REGEX = /---dom-template-\\d+---/;\nfunction prepareTemplate(strings) {\n    const template = document.createElement('template');\n    let html = '';\n    for (let i = 0; i < strings.length - 1; ++i) {\n        html += strings[i];\n        html += `---dom-template-${i}---`;\n    }\n    html += strings[strings.length - 1];\n    template.innerHTML = html;\n    const walker = template.ownerDocument.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);\n    const emptyTextNodes = [];\n    const subs = [];\n    while (walker.nextNode()) {\n        const node = walker.currentNode;\n        if (node.nodeType === Node.ELEMENT_NODE && MARKER_REGEX.test(node.tagName))\n            throw new Error('Should not use a parameter as an html tag');\n        if (node.nodeType === Node.ELEMENT_NODE && node.hasAttributes()) {\n            const element = node;\n            for (let i = 0; i < element.attributes.length; i++) {\n                const name = element.attributes[i].name;\n                const nameParts = name.split(MARKER_REGEX);\n                const valueParts = element.attributes[i].value.split(MARKER_REGEX);\n                const isSimpleValue = valueParts.length === 2 && valueParts[0] === '' && valueParts[1] === '';\n                if (nameParts.length > 1 || valueParts.length > 1)\n                    subs.push({ node: element, nameParts, valueParts, isSimpleValue, attr: name });\n            }\n        }\n        else if (node.nodeType === Node.TEXT_NODE && MARKER_REGEX.test(node.data)) {\n            const text = node;\n            const texts = text.data.split(MARKER_REGEX);\n            text.data = texts[0];\n            const anchor = node.nextSibling;\n            for (let i = 1; i < texts.length; ++i) {\n                const span = document.createElement('span');\n                node.parentNode.insertBefore(span, anchor);\n                node.parentNode.insertBefore(document.createTextNode(texts[i]), anchor);\n                subs.push({\n                    node: span,\n                    type: 'replace-node',\n                });\n            }\n            if (shouldRemoveTextNode(text))\n                emptyTextNodes.push(text);\n        }\n        else if (node.nodeType === Node.TEXT_NODE && shouldRemoveTextNode(node)) {\n            emptyTextNodes.push(node);\n        }\n    }\n    for (const emptyTextNode of emptyTextNodes)\n        emptyTextNode.remove();\n    const markedNodes = new Map();\n    for (const sub of subs) {\n        let index = markedNodes.get(sub.node);\n        if (index === undefined) {\n            index = markedNodes.size;\n            sub.node.setAttribute('dom-template-marked', 'true');\n            markedNodes.set(sub.node, index);\n        }\n        sub.nodeIndex = index;\n    }\n    return { template, subs };\n}\nfunction shouldRemoveTextNode(node) {\n    if (!node.previousSibling && !node.nextSibling)\n        return !node.data.length;\n    return (!node.previousSibling || node.previousSibling.nodeType === Node.ELEMENT_NODE) &&\n        (!node.nextSibling || node.nextSibling.nodeType === Node.ELEMENT_NODE) &&\n        (!node.data.length || SPACE_REGEX.test(node.data));\n}\nfunction renderTemplate(template, subs, values) {\n    const content = template.ownerDocument.importNode(template.content, true);\n    const boundElements = Array.from(content.querySelectorAll('[dom-template-marked]'));\n    for (const node of boundElements)\n        node.removeAttribute('dom-template-marked');\n    let valueIndex = 0;\n    const interpolateText = (texts) => {\n        let newText = texts[0];\n        for (let i = 1; i < texts.length; ++i) {\n            newText += values[valueIndex++];\n            newText += texts[i];\n        }\n        return newText;\n    };\n    for (const sub of subs) {\n        const n = boundElements[sub.nodeIndex];\n        if (sub.attr) {\n            n.removeAttribute(sub.attr);\n            const name = interpolateText(sub.nameParts);\n            const value = sub.isSimpleValue ? values[valueIndex++] : interpolateText(sub.valueParts);\n            if (BOOLEAN_ATTRS.has(name))\n                n.toggleAttribute(name, !!value);\n            else\n                n.setAttribute(name, String(value));\n        }\n        else if (sub.type === 'replace-node') {\n            const replacement = values[valueIndex++];\n            if (Array.isArray(replacement)) {\n                const fragment = document.createDocumentFragment();\n                for (const node of replacement)\n                    fragment.appendChild(node);\n                n.replaceWith(fragment);\n            }\n            else if (replacement instanceof Node) {\n                n.replaceWith(replacement);\n            }\n            else {\n                n.replaceWith(document.createTextNode(replacement || ''));\n            }\n        }\n    }\n    return content.firstChild && content.firstChild === content.lastChild ? content.firstChild : content;\n}\nfunction deepActiveElement() {\n    let activeElement = document.activeElement;\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n        activeElement = activeElement.shadowRoot.activeElement;\n    return activeElement;\n}\nexports.deepActiveElement = deepActiveElement;\n\n\n/***/ }),\n\n/***/ \"./src/cli/injected/recorder.ts\":\n/*!**************************************!*\\\n  !*** ./src/cli/injected/recorder.ts ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Recorder = void 0;\nconst selectorGenerator_1 = __webpack_require__(/*! ../../debug/injected/selectorGenerator */ \"./src/debug/injected/selectorGenerator.ts\");\nconst html_1 = __webpack_require__(/*! ./html */ \"./src/cli/injected/html.ts\");\nconst scriptSymbol = Symbol('scriptSymbol');\nclass Recorder {\n    constructor(injectedScript) {\n        this._performingAction = false;\n        this._highlightElements = [];\n        this._listeners = [];\n        this._hoveredModel = null;\n        this._hoveredElement = null;\n        this._activeModel = null;\n        this._expectProgrammaticKeyUp = false;\n        this._injectedScript = injectedScript;\n        this._outerGlassPaneElement = html_1.html `\n      <x-pw-glass style=\"\n        position: fixed;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        z-index: 2147483647;\n        pointer-events: none;\n        display: flex;\n      \">\n      </x-pw-glass>`;\n        this._tooltipElement = html_1.html `<x-pw-tooltip></x-pw-tooltip>`;\n        this._innerGlassPaneElement = html_1.html `\n      <x-pw-glass-inner style=\"flex: auto\">\n        ${this._tooltipElement}\n      </x-pw-glass-inner>`;\n        // Use a closed shadow root to prevent selectors matching our internal previews.\n        this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: 'closed' });\n        this._glassPaneShadow.appendChild(this._innerGlassPaneElement);\n        this._glassPaneShadow.appendChild(html_1.html `\n      <style>\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\n                       'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n    </style>\n    `);\n        setInterval(() => {\n            this._refreshListenersIfNeeded();\n        }, 100);\n    }\n    _refreshListenersIfNeeded() {\n        if (document.documentElement[scriptSymbol])\n            return;\n        document.documentElement[scriptSymbol] = true;\n        removeEventListeners(this._listeners);\n        this._listeners = [\n            addEventListener(document, 'click', event => this._onClick(event), true),\n            addEventListener(document, 'input', event => this._onInput(event), true),\n            addEventListener(document, 'keydown', event => this._onKeyDown(event), true),\n            addEventListener(document, 'keyup', event => this._onKeyUp(event), true),\n            addEventListener(document, 'mousedown', event => this._onMouseDown(event), true),\n            addEventListener(document, 'mouseup', event => this._onMouseUp(event), true),\n            addEventListener(document, 'mousemove', event => this._onMouseMove(event), true),\n            addEventListener(document, 'mouseleave', event => this._onMouseLeave(event), true),\n            addEventListener(document, 'focus', () => this._onFocus(), true),\n            addEventListener(document, 'scroll', () => {\n                this._hoveredModel = null;\n                this._updateHighlight();\n            }, true),\n        ];\n        document.documentElement.appendChild(this._outerGlassPaneElement);\n        if (window._recorderScriptReadyForTest)\n            window._recorderScriptReadyForTest();\n    }\n    _actionInProgress(event) {\n        // If Playwright is performing action for us, bail.\n        if (this._performingAction)\n            return true;\n        // Consume as the first thing.\n        consumeEvent(event);\n        return false;\n    }\n    _consumedDueToNoModel(event, model) {\n        if (model)\n            return false;\n        consumeEvent(event);\n        return true;\n    }\n    _consumedDueWrongTarget(event) {\n        if (this._activeModel && this._activeModel.elements[0] === deepEventTarget(event))\n            return false;\n        consumeEvent(event);\n        return true;\n    }\n    _onClick(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (this._actionInProgress(event))\n            return;\n        if (this._consumedDueToNoModel(event, this._hoveredModel))\n            return;\n        const checkbox = asCheckbox(deepEventTarget(event));\n        if (checkbox) {\n            // Interestingly, inputElement.checked is reversed inside this event handler.\n            this._performAction({\n                name: checkbox.checked ? 'check' : 'uncheck',\n                selector: this._hoveredModel.selector,\n                signals: [],\n            });\n            return;\n        }\n        this._performAction({\n            name: 'click',\n            selector: this._hoveredModel.selector,\n            signals: [],\n            button: buttonForEvent(event),\n            modifiers: modifiersForEvent(event),\n            clickCount: event.detail\n        });\n    }\n    _shouldIgnoreMouseEvent(event) {\n        const target = deepEventTarget(event);\n        const nodeName = target.nodeName;\n        if (nodeName === 'SELECT')\n            return true;\n        if (nodeName === 'INPUT' && ['date'].includes(target.type))\n            return true;\n        return false;\n    }\n    _onMouseDown(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (!this._performingAction)\n            consumeEvent(event);\n        this._activeModel = this._hoveredModel;\n    }\n    _onMouseUp(event) {\n        if (this._shouldIgnoreMouseEvent(event))\n            return;\n        if (!this._performingAction)\n            consumeEvent(event);\n    }\n    _onMouseMove(event) {\n        const target = deepEventTarget(event);\n        if (this._hoveredElement === target)\n            return;\n        this._hoveredElement = target;\n        // Mouse moved -> mark last action as committed via committing a commit action.\n        this._commitActionAndUpdateModelForHoveredElement();\n    }\n    _onMouseLeave(event) {\n        // Leaving iframe.\n        if (deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n            this._hoveredElement = null;\n            this._commitActionAndUpdateModelForHoveredElement();\n        }\n    }\n    _onFocus() {\n        const activeElement = deepActiveElement(document);\n        const result = activeElement ? selectorGenerator_1.generateSelector(this._injectedScript, activeElement) : null;\n        this._activeModel = result && result.selector ? result : null;\n        if (window._highlightUpdatedForTest)\n            window._highlightUpdatedForTest(result ? result.selector : null);\n    }\n    _commitActionAndUpdateModelForHoveredElement() {\n        if (!this._hoveredElement) {\n            this._hoveredModel = null;\n            this._updateHighlight();\n            return;\n        }\n        const hoveredElement = this._hoveredElement;\n        const { selector, elements } = selectorGenerator_1.generateSelector(this._injectedScript, hoveredElement);\n        if ((this._hoveredModel && this._hoveredModel.selector === selector) || this._hoveredElement !== hoveredElement)\n            return;\n        window.commitLastAction();\n        this._hoveredModel = selector ? { selector, elements } : null;\n        this._updateHighlight();\n        if (window._highlightUpdatedForTest)\n            window._highlightUpdatedForTest(selector);\n    }\n    _updateHighlight() {\n        const elements = this._hoveredModel ? this._hoveredModel.elements : [];\n        // Code below should trigger one layout and leave with the\n        // destroyed layout.\n        // Destroy the layout\n        this._tooltipElement.textContent = this._hoveredModel ? this._hoveredModel.selector : '';\n        this._tooltipElement.style.top = '0';\n        this._tooltipElement.style.left = '0';\n        this._tooltipElement.style.display = 'flex';\n        // Trigger layout.\n        const boxes = elements.map(e => e.getBoundingClientRect());\n        const tooltipWidth = this._tooltipElement.offsetWidth;\n        const tooltipHeight = this._tooltipElement.offsetHeight;\n        const totalWidth = this._innerGlassPaneElement.offsetWidth;\n        const totalHeight = this._innerGlassPaneElement.offsetHeight;\n        // Destroy the layout again.\n        if (boxes.length) {\n            const primaryBox = boxes[0];\n            let anchorLeft = primaryBox.left;\n            if (anchorLeft + tooltipWidth > totalWidth - 5)\n                anchorLeft = totalWidth - tooltipWidth - 5;\n            let anchorTop = primaryBox.bottom + 5;\n            if (anchorTop + tooltipHeight > totalHeight - 5) {\n                // If can't fit below, either position above...\n                if (primaryBox.top > tooltipHeight + 5) {\n                    anchorTop = primaryBox.top - tooltipHeight - 5;\n                }\n                else {\n                    // Or on top in case of large element\n                    anchorTop = totalHeight - 5 - tooltipHeight;\n                }\n            }\n            this._tooltipElement.style.top = anchorTop + 'px';\n            this._tooltipElement.style.left = anchorLeft + 'px';\n        }\n        else {\n            this._tooltipElement.style.display = 'none';\n        }\n        const pool = this._highlightElements;\n        this._highlightElements = [];\n        for (const box of boxes) {\n            const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n            highlightElement.style.borderColor = this._highlightElements.length ? 'hotpink' : '#8929ff';\n            highlightElement.style.left = box.x + 'px';\n            highlightElement.style.top = box.y + 'px';\n            highlightElement.style.width = box.width + 'px';\n            highlightElement.style.height = box.height + 'px';\n            highlightElement.style.display = 'block';\n            this._highlightElements.push(highlightElement);\n        }\n        for (const highlightElement of pool) {\n            highlightElement.style.display = 'none';\n            this._highlightElements.push(highlightElement);\n        }\n    }\n    _createHighlightElement() {\n        const highlightElement = html_1.html `\n      <x-pw-highlight style=\"\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 0;\n        height: 0;\n        border: 1px solid;\n        box-sizing: border-box;\">\n      </x-pw-highlight>`;\n        this._glassPaneShadow.appendChild(highlightElement);\n        return highlightElement;\n    }\n    _onInput(event) {\n        const target = deepEventTarget(event);\n        if (['INPUT', 'TEXTAREA'].includes(target.nodeName)) {\n            const inputElement = target;\n            const elementType = (inputElement.type || '').toLowerCase();\n            if (elementType === 'checkbox') {\n                // Checkbox is handled in click, we can't let input trigger on checkbox - that would mean we dispatched click events while recording.\n                return;\n            }\n            if (elementType === 'file') {\n                window.recordPlaywrightAction({\n                    name: 'setInputFiles',\n                    selector: this._activeModel.selector,\n                    signals: [],\n                    files: [...(inputElement.files || [])].map(file => file.name),\n                });\n                return;\n            }\n            // Non-navigating actions are simply recorded by Playwright.\n            if (this._consumedDueWrongTarget(event))\n                return;\n            window.recordPlaywrightAction({\n                name: 'fill',\n                selector: this._activeModel.selector,\n                signals: [],\n                text: inputElement.value,\n            });\n        }\n        if (target.nodeName === 'SELECT') {\n            const selectElement = target;\n            if (this._actionInProgress(event))\n                return;\n            this._performAction({\n                name: 'select',\n                selector: this._hoveredModel.selector,\n                options: [...selectElement.selectedOptions].map(option => option.value),\n                signals: []\n            });\n        }\n    }\n    _shouldGenerateKeyPressFor(event) {\n        // Backspace, Delete are changing input, will handle it there.\n        if (['Backspace', 'Delete'].includes(event.key))\n            return false;\n        // Ignore the QWERTZ shortcut for creating a at sign on MacOS\n        if (event.key === '@' && event.code === 'KeyL')\n            return false;\n        // Allow and ignore common used shortcut for pasting.\n        if (navigator.platform.includes('Mac')) {\n            if (event.key === 'v' && event.metaKey)\n                return false;\n        }\n        else {\n            if (event.key === 'v' && event.ctrlKey)\n                return false;\n            if (event.key === 'Insert' && event.shiftKey)\n                return false;\n        }\n        if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key))\n            return false;\n        const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n        if (event.key.length === 1 && !hasModifier)\n            return !!asCheckbox(deepEventTarget(event));\n        return true;\n    }\n    _onKeyDown(event) {\n        if (!this._shouldGenerateKeyPressFor(event))\n            return;\n        if (this._actionInProgress(event)) {\n            this._expectProgrammaticKeyUp = true;\n            return;\n        }\n        if (this._consumedDueWrongTarget(event))\n            return;\n        // Similarly to click, trigger checkbox on key event, not input.\n        if (event.key === ' ') {\n            const checkbox = asCheckbox(deepEventTarget(event));\n            if (checkbox) {\n                this._performAction({\n                    name: checkbox.checked ? 'uncheck' : 'check',\n                    selector: this._activeModel.selector,\n                    signals: [],\n                });\n                return;\n            }\n        }\n        this._performAction({\n            name: 'press',\n            selector: this._activeModel.selector,\n            signals: [],\n            key: event.key,\n            modifiers: modifiersForEvent(event),\n        });\n    }\n    _onKeyUp(event) {\n        if (!this._shouldGenerateKeyPressFor(event))\n            return;\n        // Only allow programmatic keyups, ignore user input.\n        if (!this._expectProgrammaticKeyUp) {\n            consumeEvent(event);\n            return;\n        }\n        this._expectProgrammaticKeyUp = false;\n    }\n    async _performAction(action) {\n        this._performingAction = true;\n        await window.performPlaywrightAction(action);\n        this._performingAction = false;\n        // Action could have changed DOM, update hovered model selectors.\n        this._commitActionAndUpdateModelForHoveredElement();\n        // If that was a keyboard action, it similarly requires new selectors for active model.\n        this._onFocus();\n        if (window._actionPerformedForTest) {\n            window._actionPerformedForTest({\n                hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n                active: this._activeModel ? this._activeModel.selector : null,\n            });\n        }\n    }\n}\nexports.Recorder = Recorder;\nfunction deepEventTarget(event) {\n    return event.composedPath()[0];\n}\nfunction deepActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n        activeElement = activeElement.shadowRoot.activeElement;\n    return activeElement;\n}\nfunction modifiersForEvent(event) {\n    return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n    switch (event.which) {\n        case 1: return 'left';\n        case 2: return 'middle';\n        case 3: return 'right';\n    }\n    return 'left';\n}\nfunction consumeEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n    if (!node || node.nodeName !== 'INPUT')\n        return null;\n    const inputElement = node;\n    return inputElement.type === 'checkbox' ? inputElement : null;\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n    target.addEventListener(eventName, listener, useCapture);\n    return { target, eventName, listener, useCapture };\n}\nfunction removeEventListeners(listeners) {\n    for (const listener of listeners)\n        listener.target.removeEventListener(listener.eventName, listener.listener, listener.useCapture);\n    listeners.splice(0, listeners.length);\n}\nexports.default = Recorder;\n\n\n/***/ }),\n\n/***/ \"./src/debug/injected/selectorGenerator.ts\":\n/*!*************************************************!*\\\n  !*** ./src/debug/injected/selectorGenerator.ts ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSelector = void 0;\nfunction generateSelector(injectedScript, targetElement) {\n    const path = [];\n    let numberOfMatchingElements = Number.MAX_SAFE_INTEGER;\n    for (let element = targetElement; element && element !== document.documentElement; element = parentElementOrShadowHost(element)) {\n        const selector = buildSelectorCandidate(element);\n        if (!selector)\n            continue;\n        const fullSelector = joinSelector([selector, ...path]);\n        const parsedSelector = injectedScript.parseSelector(fullSelector);\n        const selectorTargets = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n        if (!selectorTargets.length)\n            break;\n        if (selectorTargets[0] === targetElement)\n            return { selector: fullSelector, elements: selectorTargets };\n        if (selectorTargets.length && numberOfMatchingElements > selectorTargets.length) {\n            numberOfMatchingElements = selectorTargets.length;\n            path.unshift(selector);\n        }\n    }\n    if (document.documentElement === targetElement) {\n        return {\n            selector: '/html',\n            elements: [document.documentElement]\n        };\n    }\n    const selector = createXPath(document.documentElement, targetElement) ||\n        cssSelectorForElement(injectedScript, targetElement);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n        selector,\n        elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n}\nexports.generateSelector = generateSelector;\nfunction buildSelectorCandidate(element) {\n    const nodeName = element.nodeName.toLowerCase();\n    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {\n        if (element.hasAttribute(attribute))\n            return { engine: 'css', selector: `${nodeName}[${attribute}=${quoteString(element.getAttribute(attribute))}]` };\n    }\n    for (const attribute of ['aria-label', 'role']) {\n        if (element.hasAttribute(attribute))\n            return { engine: 'css', selector: `${element.nodeName.toLocaleLowerCase()}[${attribute}=${quoteString(element.getAttribute(attribute))}]` };\n    }\n    if (['INPUT', 'TEXTAREA'].includes(element.nodeName)) {\n        const nodeNameLowercase = element.nodeName.toLowerCase();\n        if (element.getAttribute('name'))\n            return { engine: 'css', selector: `${nodeNameLowercase}[name=${quoteString(element.getAttribute('name'))}]` };\n        if (element.getAttribute('placeholder'))\n            return { engine: 'css', selector: `${nodeNameLowercase}[placeholder=${quoteString(element.getAttribute('placeholder'))}]` };\n        if (element.getAttribute('type'))\n            return { engine: 'css', selector: `${nodeNameLowercase}[type=${quoteString(element.getAttribute('type'))}]` };\n    }\n    else if (element.nodeName === 'IMG') {\n        if (element.getAttribute('alt'))\n            return { engine: 'css', selector: `img[alt=${quoteString(element.getAttribute('alt'))}]` };\n    }\n    const textSelector = textSelectorForElement(element);\n    if (textSelector)\n        return { engine: 'text', selector: textSelector };\n    // De-prioritize id, but still use it as a last resort.\n    const idAttr = element.getAttribute('id');\n    if (idAttr && !isGuidLike(idAttr))\n        return { engine: 'css', selector: `${nodeName}[id=${quoteString(idAttr)}]` };\n    return null;\n}\nfunction parentElementOrShadowHost(element) {\n    if (element.parentElement)\n        return element.parentElement;\n    if (!element.parentNode)\n        return null;\n    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n        return element.parentNode.host;\n    return null;\n}\nfunction cssSelectorForElement(injectedScript, targetElement) {\n    const root = targetElement.ownerDocument;\n    const tokens = [];\n    function uniqueCSSSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        const selector = path.join(' ');\n        const parsedSelector = injectedScript.parseSelector(selector);\n        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);\n        return node === targetElement ? selector : undefined;\n    }\n    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n        const nodeName = element.nodeName.toLowerCase();\n        // Element ID is the strongest signal, use it.\n        let bestTokenForLevel = '';\n        if (element.id) {\n            const token = /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(element.id) ? '#' + element.id : `[id=\"${element.id}\"]`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return selector;\n            bestTokenForLevel = token;\n        }\n        const parent = element.parentNode;\n        // Combine class names until unique.\n        const classes = Array.from(element.classList);\n        for (let i = 0; i < classes.length; ++i) {\n            const token = '.' + classes.slice(0, i + 1).join('.');\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return selector;\n            // Even if not unique, does this subset of classes uniquely identify node as a child?\n            if (!bestTokenForLevel && parent) {\n                const sameClassSiblings = parent.querySelectorAll(token);\n                if (sameClassSiblings.length === 1)\n                    bestTokenForLevel = token;\n            }\n        }\n        // Ordinal is the weakest signal.\n        if (parent) {\n            const siblings = Array.from(parent.children);\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n            const selector = uniqueCSSSelector(token);\n            if (selector)\n                return selector;\n            if (!bestTokenForLevel)\n                bestTokenForLevel = token;\n        }\n        else if (!bestTokenForLevel) {\n            bestTokenForLevel = nodeName;\n        }\n        tokens.unshift(bestTokenForLevel);\n    }\n    return uniqueCSSSelector();\n}\nfunction textSelectorForElement(node) {\n    const maxLength = 30;\n    let needsRegex = false;\n    let trimmedText = null;\n    for (const child of node.childNodes) {\n        if (child.nodeType !== Node.TEXT_NODE)\n            continue;\n        if (child.textContent && child.textContent.trim()) {\n            if (trimmedText)\n                return null;\n            trimmedText = child.textContent.trim().substr(0, maxLength);\n            needsRegex = child.textContent !== trimmedText;\n        }\n        else {\n            needsRegex = true;\n        }\n    }\n    if (!trimmedText)\n        return null;\n    return needsRegex ? `/.*${escapeForRegex(trimmedText)}.*/` : `\"${trimmedText}\"`;\n}\nfunction escapeForRegex(text) {\n    return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction quoteString(text) {\n    return `\"${text.replaceAll(/\"/g, '\\\\\"')}\"`;\n}\nfunction joinSelector(path) {\n    const tokens = [];\n    let lastEngine = '';\n    for (const { engine, selector } of path) {\n        if (tokens.length && (lastEngine !== 'css' || engine !== 'css'))\n            tokens.push('>>');\n        lastEngine = engine;\n        if (engine === 'css')\n            tokens.push(selector);\n        else\n            tokens.push(`${engine}=${selector}`);\n    }\n    return tokens.join(' ');\n}\nfunction isGuidLike(id) {\n    let lastCharacterType;\n    let transitionCount = 0;\n    for (let i = 0; i < id.length; ++i) {\n        const c = id[i];\n        let characterType;\n        if (c === '-' || c === '_')\n            continue;\n        if (c >= 'a' && c <= 'z')\n            characterType = 'lower';\n        else if (c >= 'A' && c <= 'Z')\n            characterType = 'upper';\n        else if (c >= '0' && c <= '9')\n            characterType = 'digit';\n        else\n            characterType = 'other';\n        if (characterType === 'lower' && lastCharacterType === 'upper') {\n            lastCharacterType = characterType;\n            continue;\n        }\n        if (lastCharacterType && lastCharacterType !== characterType)\n            ++transitionCount;\n        lastCharacterType = characterType;\n    }\n    return transitionCount >= id.length / 4;\n}\nfunction createXPath(root, targetElement) {\n    const maxTextLength = 80;\n    const minMeaningfulSelectorLegth = 100;\n    const maybeDocument = root instanceof Document ? root : root.ownerDocument;\n    if (!maybeDocument)\n        return;\n    const document = maybeDocument;\n    const xpathCache = new Map();\n    const tokens = [];\n    function evaluateXPath(expression) {\n        let nodes = xpathCache.get(expression);\n        if (!nodes) {\n            nodes = [];\n            try {\n                const result = document.evaluate(expression, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n                for (let node = result.iterateNext(); node; node = result.iterateNext()) {\n                    if (node.nodeType === Node.ELEMENT_NODE)\n                        nodes.push(node);\n                }\n            }\n            catch (e) {\n            }\n            xpathCache.set(expression, nodes);\n        }\n        return nodes;\n    }\n    function uniqueXPathSelector(prefix) {\n        const path = tokens.slice();\n        if (prefix)\n            path.unshift(prefix);\n        let selector = '//' + path.join('/');\n        while (selector.includes('///'))\n            selector = selector.replace('///', '//');\n        if (selector.endsWith('/'))\n            selector = selector.substring(0, selector.length - 1);\n        const nodes = evaluateXPath(selector);\n        if (nodes[0] === targetElement)\n            return selector;\n        // If we are looking at a small set of elements with long selector, fall back to ordinal.\n        if (nodes.length < 5 && selector.length > minMeaningfulSelectorLegth) {\n            const index = nodes.indexOf(targetElement);\n            if (index !== -1)\n                return `(${selector})[${index + 1}]`;\n        }\n        return undefined;\n    }\n    function escapeAndCap(text) {\n        text = text.substring(0, maxTextLength);\n        // XPath 1.0 does not support quote escaping.\n        // 1. If there are no single quotes - use them.\n        if (text.indexOf(`'`) === -1)\n            return `'${text}'`;\n        // 2. If there are no double quotes - use them to enclose text.\n        if (text.indexOf(`\"`) === -1)\n            return `\"${text}\"`;\n        // 3. Otherwise, use popular |concat| trick.\n        const Q = `'`;\n        return `concat(${text.split(Q).map(token => Q + token + Q).join(`, \"'\", `)})`;\n    }\n    const defaultAttributes = new Set(['title', 'aria-label', 'disabled', 'role']);\n    const importantAttributes = new Map([\n        ['form', ['action']],\n        ['img', ['alt']],\n        ['input', ['placeholder', 'type', 'name']],\n        ['textarea', ['placeholder', 'type', 'name']],\n    ]);\n    let usedTextConditions = false;\n    for (let element = targetElement; element && element !== root; element = element.parentElement) {\n        const nodeName = element.nodeName.toLowerCase();\n        const tag = nodeName === 'svg' ? '*' : nodeName;\n        const tagConditions = [];\n        if (nodeName === 'svg')\n            tagConditions.push('local-name()=\"svg\"');\n        const attrConditions = [];\n        const importantAttrs = [...defaultAttributes, ...(importantAttributes.get(tag) || [])];\n        for (const attr of importantAttrs) {\n            const value = element.getAttribute(attr);\n            if (value && value.length < maxTextLength)\n                attrConditions.push(`normalize-space(@${attr})=${escapeAndCap(value)}`);\n            else if (value)\n                attrConditions.push(`starts-with(normalize-space(@${attr}), ${escapeAndCap(value)})`);\n        }\n        const text = document.evaluate('normalize-space(.)', element).stringValue;\n        const textConditions = [];\n        if (tag !== 'select' && text.length && !usedTextConditions) {\n            if (text.length < maxTextLength)\n                textConditions.push(`normalize-space(.)=${escapeAndCap(text)}`);\n            else\n                textConditions.push(`starts-with(normalize-space(.), ${escapeAndCap(text)})`);\n            usedTextConditions = true;\n        }\n        // Always retain the last tag.\n        const conditions = [...tagConditions, ...textConditions, ...attrConditions];\n        const token = conditions.length ? `${tag}[${conditions.join(' and ')}]` : (tokens.length ? '' : tag);\n        const selector = uniqueXPathSelector(token);\n        if (selector)\n            return selector;\n        const parent = element.parentElement;\n        let ordinal = -1;\n        if (parent) {\n            const siblings = Array.from(parent.children);\n            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n            if (sameTagSiblings.length > 1)\n                ordinal = sameTagSiblings.indexOf(element);\n        }\n        // Do not include text into this token, only tag / attributes.\n        // Topmost node will get all the text.\n        const conditionsString = conditions.length ? `[${conditions.join(' and ')}]` : '';\n        const ordinalString = ordinal >= 0 ? `[${ordinal + 1}]` : '';\n        tokens.unshift(`${tag}${ordinalString}${conditionsString}`);\n    }\n    return uniqueXPathSelector();\n}\n\n\n/***/ })\n\n/******/ })[\"default\"];";
//# sourceMappingURL=recorderSource.js.map